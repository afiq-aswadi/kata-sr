"""Dynamic programming kata."""



def fibonacci_memo(n: int) -> int:
    """Compute nth Fibonacci number using memoization.

    Args:
        n: index (0-indexed)

    Returns:
        nth Fibonacci number
    """
    # TODO: implement with memoization (top-down)
    # BLANK_START
    pass
    # BLANK_END


def fibonacci_tabulation(n: int) -> int:
    """Compute nth Fibonacci number using tabulation.

    Args:
        n: index (0-indexed)

    Returns:
        nth Fibonacci number
    """
    # TODO: implement with tabulation (bottom-up)
    # BLANK_START
    pass
    # BLANK_END


def knapsack(weights: list[int], values: list[int], capacity: int) -> int:
    """Solve 0/1 knapsack problem.

    Args:
        weights: weight of each item
        values: value of each item
        capacity: maximum weight capacity

    Returns:
        maximum value achievable
    """
    # TODO: implement using dynamic programming
    # BLANK_START
    pass
    # BLANK_END


def longest_common_subsequence(s1: str, s2: str) -> int:
    """Find length of longest common subsequence.

    Args:
        s1: first string
        s2: second string

    Returns:
        length of LCS
    """
    # TODO: implement using dynamic programming
    # BLANK_START
    pass
    # BLANK_END


def coin_change(coins: list[int], amount: int) -> int:
    """Find minimum number of coins to make amount.

    Args:
        coins: available coin denominations
        amount: target amount

    Returns:
        minimum number of coins, or -1 if impossible
    """
    # TODO: implement using dynamic programming
    # BLANK_START
    pass
    # BLANK_END
