<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NeetCode Binary Search: Logarithmic Time Mastery ¬∑ Workbook</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=Fira+Code:wght@400;500&family=DM+Sans:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <style>
    :root {
      --cream: #faf8f3;
      --paper: #f5f2ea;
      --ink: #2a2520;
      --rust: #c85a4e;
      --navy: #344955;
      --sage: #7a9d8b;
      --gold: #d4a574;
      --shadow: rgba(42, 37, 32, 0.08);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'DM Sans', sans-serif;
      background: linear-gradient(135deg, var(--cream) 0%, var(--paper) 100%);
      color: var(--ink);
      line-height: 1.7;
      min-height: 100vh;
      padding: 0;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 31px,
          rgba(52, 73, 85, 0.02) 31px,
          rgba(52, 73, 85, 0.02) 32px
        );
      pointer-events: none;
      z-index: 1;
    }

    .page {
      position: relative;
      z-index: 2;
      max-width: 900px;
      margin: 0 auto;
      padding: 80px 32px;
    }

    header {
      margin-bottom: 64px;
      animation: fadeSlideIn 0.8s ease-out;
    }

    @keyframes fadeSlideIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    h1 {
      font-family: 'Crimson Pro', serif;
      font-size: 56px;
      font-weight: 700;
      color: var(--navy);
      letter-spacing: -0.03em;
      line-height: 1.1;
      margin-bottom: 16px;
    }

    .subtitle {
      font-size: 20px;
      color: var(--rust);
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      margin-bottom: 24px;
    }

    .summary {
      font-size: 18px;
      color: var(--ink);
      max-width: 700px;
      line-height: 1.8;
      opacity: 0.85;
    }

    .section {
      margin-bottom: 48px;
      animation: fadeSlideIn 0.8s ease-out;
      animation-fill-mode: both;
    }

    h2 {
      font-family: 'Crimson Pro', serif;
      font-size: 32px;
      font-weight: 600;
      color: var(--navy);
      margin-bottom: 24px;
      letter-spacing: -0.02em;
    }

    h3 {
      font-family: 'Crimson Pro', serif;
      font-size: 24px;
      font-weight: 600;
      color: var(--navy);
      margin-bottom: 16px;
      letter-spacing: -0.01em;
    }

    p {
      margin-bottom: 16px;
      font-size: 16px;
    }

    .card {
      background: white;
      border: 1px solid rgba(52, 73, 85, 0.12);
      border-radius: 8px;
      padding: 32px;
      margin-bottom: 32px;
      box-shadow: 0 4px 12px var(--shadow);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(42, 37, 32, 0.12);
    }

    .visual-box {
      background: var(--paper);
      border: 2px solid var(--sage);
      border-radius: 8px;
      padding: 24px;
      margin: 24px 0;
      font-family: 'Fira Code', monospace;
      font-size: 13px;
      line-height: 1.4;
      overflow-x: auto;
      white-space: pre;
      max-width: 100%;
    }

    .intuition {
      background: linear-gradient(135deg, rgba(122, 157, 139, 0.15), rgba(212, 165, 116, 0.15));
      border-left: 4px solid var(--sage);
      border-radius: 4px;
      padding: 20px;
      margin: 20px 0;
    }

    .intuition-title {
      font-weight: 600;
      color: var(--sage);
      margin-bottom: 8px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    pre {
      background: var(--navy);
      color: var(--cream);
      border-radius: 8px;
      padding: 20px;
      overflow-x: auto;
      margin: 20px 0;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      line-height: 1.6;
    }

    code {
      font-family: 'Fira Code', monospace;
      background: rgba(52, 73, 85, 0.08);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 14px;
    }

    pre code {
      background: none;
      padding: 0;
    }

    .pill {
      display: inline-block;
      background: var(--sage);
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 500;
      margin-right: 8px;
      margin-bottom: 8px;
    }

    ul, ol {
      margin-left: 24px;
      margin-bottom: 16px;
    }

    li {
      margin-bottom: 8px;
    }

    .pattern-title {
      background: var(--gold);
      color: var(--navy);
      padding: 8px 16px;
      border-radius: 6px;
      display: inline-block;
      font-weight: 600;
      margin-bottom: 16px;
      font-size: 14px;
    }

    .complexity {
      font-family: 'Fira Code', monospace;
      color: var(--sage);
      font-size: 13px;
      font-weight: 500;
    }

    a {
      color: var(--rust);
      text-decoration: none;
      border-bottom: 1px solid transparent;
      transition: border-color 0.2s ease;
    }

    a:hover {
      border-bottom-color: var(--rust);
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="subtitle">NeetCode Pattern</div>
      <h1>Binary Search</h1>
      <p class="summary">
        Master binary search patterns from basic sorted arrays to complex search spaces.
        This powerful technique reduces search time from O(n) to O(log n) by repeatedly
        dividing the search space in half‚Äîthe foundation of efficient algorithms.
      </p>
    </header>

    <section class="section">
      <h2>Core Intuition</h2>
      <div class="intuition">
        <div class="intuition-title">üí° The Key Insight</div>
        <p>
          Binary search exploits sorted order to eliminate half the search space with
          each comparison. By always checking the middle and deciding which half contains
          the target, we achieve logarithmic time complexity.
        </p>
      </div>

      <h3>Visual Pattern</h3>
      <div class="visual-box">
Iteration 1:  [1, 3, 5, 7, 9, 11, 13, 15]  Target: 11
               L        M           R

               11 > 7 ‚Üí search right half

Iteration 2:           [9, 11, 13, 15]
                        L   M       R

                        11 < 13 ‚Üí search left half

Iteration 3:           [9, 11]
                        L/M  R

                        11 == 11 ‚Üí FOUND! ‚úì

Each step cuts search space in half:
8 ‚Üí 4 ‚Üí 2 ‚Üí 1  (log‚ÇÇ(8) = 3 steps)
      </div>

      <h3>When to Use Binary Search</h3>
      <ul>
        <li><strong>Sorted arrays:</strong> Classic search in ordered data</li>
        <li><strong>Search space:</strong> Finding min/max value that satisfies condition</li>
        <li><strong>Modified arrays:</strong> Rotated, shifted, or partially sorted</li>
        <li><strong>Matrix search:</strong> Row-wise and column-wise sorted</li>
      </ul>
    </section>

    <section class="section">
      <h2>Core Pattern: Template</h2>
      <pre><code class="language-python">def binary_search_template(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow

        if arr[mid] == target:
            return mid  # Found
        elif arr[mid] < target:
            left = mid + 1   # Search right half
        else:
            right = mid - 1  # Search left half

    return -1  # Not found</code></pre>

      <div class="intuition">
        <div class="intuition-title">‚ö†Ô∏è Common Pitfalls</div>
        <ul>
          <li><code>while left <= right</code> vs <code>left < right</code> ‚Äì depends on problem</li>
          <li><code>mid = (left + right) // 2</code> can overflow in other languages</li>
          <li><code>left = mid + 1</code> vs <code>left = mid</code> ‚Äì be consistent!</li>
          <li>Return value when not found: -1, left, or right?</li>
        </ul>
      </div>
    </section>

    <section class="section">
      <h2>Exercise 1: Classic Binary Search</h2>
      <div class="card">
        <div class="pattern-title">Foundation</div>
        <h3>Objective</h3>
        <p>
          Implement iterative binary search on a sorted array to find a target value.
          Return the index if found, -1 otherwise.
        </p>

        <h3>Visual Example</h3>
        <div class="visual-box">
Array: [-1, 0, 3, 5, 9, 12]  Target: 9

Step 1: [ -1, 0, 3, 5, 9, 12 ]
          L        M        R
          5 < 9 ‚Üí search right

Step 2:              [ 9, 12 ]
                      L/M  R
          9 == 9 ‚Üí return 4 ‚úì
        </div>

        <h3>Key Pattern</h3>
        <pre><code class="language-python">def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1</code></pre>

        <p><span class="complexity">Time: O(log n) | Space: O(1)</span></p>
      </div>
    </section>

    <section class="section">
      <h2>Exercise 2: Search in Rotated Sorted Array</h2>
      <div class="card">
        <div class="pattern-title">Modified Binary Search</div>
        <h3>Objective</h3>
        <p>
          Search for a target in an array that was sorted but then rotated at some pivot.
        </p>

        <div class="intuition">
          <div class="intuition-title">üí° Key Insight</div>
          <p>
            At least one half (left or right) is always sorted. Identify which half is
            sorted by comparing mid with boundaries, then check if target lies in that
            sorted half. If yes, search there; otherwise, search the other half.
          </p>
        </div>

        <h3>Visual Example</h3>
        <div class="visual-box">
Array: [4, 5, 6, 7, 0, 1, 2]  Target: 0
        L        M        R

Step 1: Left half [4,5,6] is sorted (4 < 7)
        Target 0 NOT in [4,7] ‚Üí search right

Step 2:              [0, 1, 2]
                      L  M  R
        Right half is sorted
        Target 0 in [0,2] ‚Üí search left

Step 3:              [0]
                     L/M/R
        Found! Return 4 ‚úì
        </div>

        <h3>Key Pattern</h3>
        <pre><code class="language-python">def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if nums[mid] == target:
            return mid

        # Check which half is sorted
        if nums[left] <= nums[mid]:  # Left half sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1  # Target in left
            else:
                left = mid + 1   # Target in right
        else:  # Right half sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1   # Target in right
            else:
                right = mid - 1  # Target in left

    return -1</code></pre>

        <p><span class="complexity">Time: O(log n) | Space: O(1)</span></p>
      </div>
    </section>

    <section class="section">
      <h2>Exercise 3: Koko Eating Bananas</h2>
      <div class="card">
        <div class="pattern-title">Binary Search on Answer Space</div>
        <h3>Objective</h3>
        <p>
          Find the minimum eating speed k where Koko can eat all bananas in h hours.
          At speed k, Koko eats k bananas/hour (one pile at a time).
        </p>

        <div class="intuition">
          <div class="intuition-title">üí° Paradigm Shift</div>
          <p>
            Binary search isn't always on the input array! Here we search on the
            <strong>answer space</strong> (eating speeds 1 to max(piles)). For each
            candidate speed, check if it's feasible. Use binary search to find the
            minimum feasible speed.
          </p>
        </div>

        <h3>Visual Example</h3>
        <div class="visual-box">
Piles: [3, 6, 7, 11]  h: 8 hours

Try k = 6:
  3/6 = 1 hr, 6/6 = 1 hr, 7/6 = 2 hr, 11/6 = 2 hr
  Total = 6 hours ‚â§ 8 ‚úì (feasible)

Try k = 3:
  3/3 = 1 hr, 6/3 = 2 hr, 7/3 = 3 hr, 11/3 = 4 hr
  Total = 10 hours > 8 ‚úó (too slow)

Binary search range [3, 11] ‚Üí answer: 4
        </div>

        <h3>Key Pattern</h3>
        <pre><code class="language-python">def minEatingSpeed(piles: List[int], h: int) -> int:
    def canFinish(speed):
        hours = 0
        for pile in piles:
            hours += (pile + speed - 1) // speed  # Ceiling division
        return hours <= h

    left, right = 1, max(piles)

    while left < right:
        mid = left + (right - left) // 2

        if canFinish(mid):
            right = mid  # Try slower speed
        else:
            left = mid + 1  # Need faster speed

    return left</code></pre>

        <p><span class="complexity">Time: O(n log m) | Space: O(1)</span>
        <br><small>where n = len(piles), m = max(piles)</small></p>
      </div>
    </section>

    <section class="section">
      <h2>Exercise 4: Find Minimum in Rotated Array</h2>
      <div class="card">
        <div class="pattern-title">Finding Inflection Point</div>
        <h3>Objective</h3>
        <p>
          Find the minimum element in a rotated sorted array.
        </p>

        <div class="intuition">
          <div class="intuition-title">üí° The Trick</div>
          <p>
            Compare mid with the right boundary (not left!). If nums[mid] > nums[right],
            the minimum is in the right half (includes the rotation point). Otherwise,
            it's in the left half (including mid itself).
          </p>
        </div>

        <h3>Visual Example</h3>
        <div class="visual-box">
Array: [4, 5, 6, 7, 0, 1, 2]
        L        M        R

Step 1: 7 > 2 ‚Üí minimum in right half
                      [0, 1, 2]
                       L  M  R

Step 2: 1 < 2 ‚Üí minimum in left half (including mid)
                       [0, 1]
                        L  M/R

Step 3: 0 < 1 ‚Üí minimum in left (mid)
        Return 0 ‚úì
        </div>

        <h3>Key Pattern</h3>
        <pre><code class="language-python">def findMin(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1

    while left < right:
        mid = left + (right - left) // 2

        # Compare with right boundary
        if nums[mid] > nums[right]:
            left = mid + 1   # Min in right half
        else:
            right = mid      # Min in left half (or mid)

    return nums[left]</code></pre>

        <p><span class="complexity">Time: O(log n) | Space: O(1)</span></p>
      </div>
    </section>

    <section class="section">
      <h2>Exercise 5: Search 2D Matrix</h2>
      <div class="card">
        <div class="pattern-title">Binary Search Adaptation</div>
        <h3>Objective</h3>
        <p>
          Search a 2D matrix where each row is sorted and the first element of each
          row is greater than the last element of the previous row.
        </p>

        <div class="intuition">
          <div class="intuition-title">üí° Key Insight</div>
          <p>
            The matrix can be treated as a single sorted 1D array! Map 2D coordinates
            to 1D index: <code>index = row √ó cols + col</code>. Or use two binary searches:
            first find the row, then search within that row.
          </p>
        </div>

        <h3>Visual Example</h3>
        <div class="visual-box">
Matrix:  [ 1,  3,  5,  7]
         [10, 11, 16, 20]
         [23, 30, 34, 60]
Target: 3

Treat as 1D: [1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]
                ‚Üë
             Found at index 1
             ‚Üí row = 1 // 4 = 0, col = 1 % 4 = 1
             ‚Üí return True
        </div>

        <h3>Key Pattern</h3>
        <pre><code class="language-python">def searchMatrix(matrix: List[List[int]], target: int) -> bool:
    if not matrix or not matrix[0]:
        return False

    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1

    while left <= right:
        mid = left + (right - left) // 2
        # Convert 1D index to 2D coordinates
        row, col = mid // cols, mid % cols
        mid_val = matrix[row][col]

        if mid_val == target:
            return True
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1

    return False

# Alternative: Two binary searches
def searchMatrix(matrix: List[List[int]], target: int) -> bool:
    # Binary search to find the row
    top, bottom = 0, len(matrix) - 1
    while top <= bottom:
        mid_row = (top + bottom) // 2
        if target < matrix[mid_row][0]:
            bottom = mid_row - 1
        elif target > matrix[mid_row][-1]:
            top = mid_row + 1
        else:
            break  # Found the row

    # Binary search within the row
    row = (top + bottom) // 2
    left, right = 0, len(matrix[0]) - 1
    while left <= right:
        mid = (left + right) // 2
        if matrix[row][mid] == target:
            return True
        elif matrix[row][mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return False</code></pre>

        <p><span class="complexity">Time: O(log(m√ón)) | Space: O(1)</span></p>
      </div>
    </section>

    <section class="section">
      <h2>Exercise 6: Time-Based Key-Value Store</h2>
      <div class="card">
        <div class="pattern-title">Binary Search with Timestamps</div>
        <h3>Objective</h3>
        <p>
          Design a time-based key-value store that supports <code>set(key, value, timestamp)</code>
          and <code>get(key, timestamp)</code> returning the value at or before the given timestamp.
        </p>

        <div class="intuition">
          <div class="intuition-title">üí° The Pattern</div>
          <p>
            Store values for each key as a list of (timestamp, value) pairs. Since timestamps
            are always increasing, the list is sorted. Use binary search to find the rightmost
            timestamp ‚â§ query timestamp (lower bound pattern).
          </p>
        </div>

        <h3>Visual Example</h3>
        <div class="visual-box">
Operations:
  set("foo", "bar", 1)
  set("foo", "bar2", 4)
  get("foo", 4)   ‚Üí "bar2"
  get("foo", 5)   ‚Üí "bar2" (closest ‚â§ 5)
  get("foo", 0)   ‚Üí ""     (no value before 0)

Storage:
  store = {
    "foo": [(1, "bar"), (4, "bar2")]
                ‚Üë           ‚Üë
    Binary search for timestamp ‚â§ query
  }
        </div>

        <h3>Key Pattern</h3>
        <pre><code class="language-python">class TimeMap:
    def __init__(self):
        self.store = {}  # key -> list of (timestamp, value)

    def set(self, key: str, value: str, timestamp: int) -> None:
        if key not in self.store:
            self.store[key] = []
        self.store[key].append((timestamp, value))

    def get(self, key: str, timestamp: int) -> str:
        if key not in self.store:
            return ""

        values = self.store[key]
        left, right = 0, len(values) - 1
        result = ""

        # Binary search for rightmost timestamp <= query
        while left <= right:
            mid = left + (right - left) // 2

            if values[mid][0] <= timestamp:
                result = values[mid][1]  # Valid candidate
                left = mid + 1   # Look for later timestamps
            else:
                right = mid - 1  # Too late, search earlier

        return result</code></pre>

        <p><span class="complexity">set: O(1) | get: O(log n) | Space: O(n)</span></p>
      </div>
    </section>

    <section class="section">
      <h2>Exercise 7: Median of Two Sorted Arrays</h2>
      <div class="card">
        <div class="pattern-title">Advanced Binary Search</div>
        <h3>Objective</h3>
        <p>
          Find the median of two sorted arrays in O(log(min(m,n))) time using
          binary search on partition points.
        </p>

        <div class="intuition">
          <div class="intuition-title">üí° Advanced Insight</div>
          <p>
            Median divides elements into two equal halves. Use binary search to find
            the correct partition point in the smaller array. For valid partition:
            all elements in left half ‚â§ all elements in right half. Check condition:
            <code>maxLeft1 ‚â§ minRight2 AND maxLeft2 ‚â§ minRight1</code>
          </p>
        </div>

        <h3>Visual Example</h3>
        <div class="visual-box">
nums1 = [1, 3, 8, 9, 15]
nums2 = [7, 11, 18, 19, 21, 25]

Total elements: 11 (odd), median is 6th element

Partition nums1:      [1, 3, 8 | 9, 15]
Partition nums2: [7, 11, 18, 19 | 21, 25]

Left half: 1,3,8,7,11,18  (6 elements, max=18)
Right half: 9,15,19,21,25 (5 elements, min=9)

Check: max(left) ‚â§ min(right)?
       max(8, 18) ‚â§ min(9, 21)
       18 ‚â§ 9? NO! ‚Üí move partition

Final partition: [1, 3 | 8, 9, 15]
                 [7, 11, 18 | 19, 21, 25]

Left: 1,3,7,11,18  (max=11)
Right: 8,9,15,19,21,25 (min=8)
Wait, 11 > 8, still wrong...

Correct partition: [1, 3, 8, 9 | 15]
                   [7, 11 | 18, 19, 21, 25]
Left max = 11, Right min = 15 ‚Üí median = 11
        </div>

        <h3>Key Pattern</h3>
        <pre><code class="language-python">def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    # Ensure nums1 is the smaller array
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1

    m, n = len(nums1), len(nums2)
    left, right = 0, m

    while left <= right:
        partition1 = (left + right) // 2
        partition2 = (m + n + 1) // 2 - partition1

        # Handle edge cases
        maxLeft1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
        minRight1 = float('inf') if partition1 == m else nums1[partition1]

        maxLeft2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
        minRight2 = float('inf') if partition2 == n else nums2[partition2]

        # Check if we found the correct partition
        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
            # Odd total length
            if (m + n) % 2 == 1:
                return max(maxLeft1, maxLeft2)
            # Even total length
            else:
                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2
        elif maxLeft1 > minRight2:
            # Too far right in nums1, move left
            right = partition1 - 1
        else:
            # Too far left in nums1, move right
            left = partition1 + 1

    raise ValueError("Input arrays are not sorted")</code></pre>

        <p><span class="complexity">Time: O(log(min(m,n))) | Space: O(1)</span></p>
      </div>
    </section>

    <section class="section">
      <h2>Binary Search Variations</h2>
      <div class="card">
        <h3>1. Different Return Values</h3>
        <ul>
          <li><strong>Exact match:</strong> Return index or -1</li>
          <li><strong>Lower bound:</strong> First position ‚â• target (return <code>left</code>)</li>
          <li><strong>Upper bound:</strong> First position > target (return <code>left</code>)</li>
          <li><strong>Closest value:</strong> Check both <code>left</code> and <code>right</code></li>
        </ul>

        <h3>2. Loop Condition Variations</h3>
        <pre><code class="language-python"># Pattern 1: left <= right (most common)
while left <= right:
    mid = (left + right) // 2
    # Update: left = mid + 1 or right = mid - 1

# Pattern 2: left < right (no equal)
while left < right:
    mid = (left + right) // 2
    # Update: left = mid + 1 or right = mid

# Pattern 3: left + 1 < right (preserve 2 elements)
while left + 1 < right:
    mid = (left + right) // 2
    # Update: left = mid or right = mid</code></pre>

        <h3>3. Common Applications</h3>
        <ul>
          <li><strong>Find peak element:</strong> Compare mid with neighbors</li>
          <li><strong>Search 2D matrix:</strong> Treat as 1D array</li>
          <li><strong>Capacity problems:</strong> "Minimize maximum" or "maximize minimum"</li>
          <li><strong>Time-based lookups:</strong> Find value at or before timestamp</li>
        </ul>
      </div>
    </section>

    <section class="section">
      <h2>Debugging Checklist</h2>
      <div class="card">
        <h3>Common Issues</h3>
        <ol>
          <li><strong>Infinite loop:</strong> Check if left/right always update
            <ul>
              <li>Use <code>left = mid + 1</code> and <code>right = mid - 1</code>, OR</li>
              <li>Use <code>left = mid</code> and <code>right = mid</code> with <code>left < right</code></li>
            </ul>
          </li>
          <li><strong>Off-by-one:</strong> Test with arrays of size 1, 2, 3</li>
          <li><strong>Wrong boundary:</strong> Verify initial left/right values</li>
          <li><strong>Mid calculation:</strong> Use <code>left + (right - left) // 2</code> to avoid overflow</li>
        </ol>

        <h3>Test Cases to Always Check</h3>
        <ul>
          <li>Empty array: <code>[]</code></li>
          <li>Single element: <code>[1]</code></li>
          <li>Target at boundaries: first or last element</li>
          <li>Target not in array</li>
          <li>All elements same: <code>[5, 5, 5, 5]</code></li>
        </ul>
      </div>
    </section>

    <section class="section">
      <h2>Learning Resources</h2>
      <ul>
        <li><a href="https://neetcode.io/courses/dsa-for-beginners/12" target="_blank">NeetCode Binary Search Guide</a></li>
        <li><a href="https://leetcode.com/discuss/study-guide/786126/Python-Powerful-Ultimate-Binary-Search-Template" target="_blank">Ultimate Binary Search Template</a></li>
      </ul>
    </section>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
</body>
</html>
